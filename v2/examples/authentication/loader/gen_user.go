// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots
package loader

import (
	"context"
	"fmt"
	"sync"
	"time"

	sq "github.com/Masterminds/squirrel"
	"github.com/example/todo/gnorm"
	"github.com/example/todo/gnorm/public/user"
	"github.com/example/todo/models"
	opentracing "github.com/opentracing/opentracing-go"
)

// UserFetchRequest A request for a user object, to be batched
type UserFetchRequest struct {
	UserID int
	Reply  chan UserFetchReply
}

// UserFetchReply A reply with the requested object or an error
type UserFetchReply struct {
	Row   user.Row
	Error error
}

var userInitialised bool
var userFRs []UserFetchRequest
var userMX sync.RWMutex

// OneUser Returns a single User with the given where clauses and order
func (l *PostgresLoader) OneUser(ctx context.Context, where []sq.Sqlizer, order *gnorm.Order) (o user.Row, err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "OneUser")
	defer span.Finish()

	r, err := user.One(ctx, l.pool, where, order)

	o = hydrateModelUser(ctx, r)

	return o, err
}

// GetUser Returns User with given ID
func (l *PostgresLoader) GetUser(ctx context.Context, id int) (o user.Row, err error) {
	return l.getUser(ctx, id, l.pool)
}

// getUser Returns User with given ID, using provided DB connection
func (l *PostgresLoader) getUser(ctx context.Context, id int, db gnorm.DB) (o user.Row, err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "GetUser")
	defer span.Finish()

	r, err := l.batchedGetUser(id, l.pool)

	if err != nil {
		err = sanitiseError(err)
		return
	}

	o = hydrateModelUser(ctx, r)

	return
}

func (l *PostgresLoader) batchedGetUser(id int, db gnorm.DB) (o user.Row, err error) {
	userMX.RLock()
	if !userInitialised {
		err = fmt.Errorf("batchedGetUser not initialised.  Add 'go loader.runUserBatcher()' to init")
	}
	userMX.RUnlock()
	if err != nil {
		return
	}

	rchan := make(chan UserFetchReply)
	r := UserFetchRequest{
		UserID: id,
		Reply:  rchan,
	}

	userMX.Lock()
	userFRs = append(userFRs, r)
	userMX.Unlock()

	reply := <-rchan

	return reply.Row, reply.Error
}

func (l *PostgresLoader) runUserBatcher() {
	userMX.Lock()
	userInitialised = true
	userMX.Unlock()
	for {
		time.Sleep(time.Millisecond * 20)

		userMX.Lock()
		if len(userFRs) > 0 {
			var users []user.Row
			var err error
			var ids []int

			for _, r := range userFRs {
				ids = append(ids, r.UserID)
			}

			users, err = user.Query(context.Background(), l.pool, []sq.Sqlizer{gnorm.InInt(user.UserIDCol, ids)})

		OUTER:
			for _, r := range userFRs {
				for _, c := range users {
					if c.UserID == r.UserID {
						r.Reply <- UserFetchReply{Row: c, Error: nil}
						continue OUTER
					}
				}

				err2 := err

				if err2 == nil {
					err2 = fmt.Errorf("Not found")
				}
				r.Reply <- UserFetchReply{Error: err2}
			}

			userFRs = []UserFetchRequest{}
		}

		userMX.Unlock()
	}
}

// GetAllUser Returns an array of all User entries, using the provided filter
// For an explanation on how the query works, and reversing orders, etc:
// https://use-the-index-luke.com/sql/partial-results/fetch-next-page
func (l *PostgresLoader) GetAllUser(ctx context.Context, filter models.Filter) (all []user.Row, pi models.PageInfo, count int, err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "GetAllUser")
	defer span.Finish()

	descending := filter.Order.Descending
	// If filter.Before, we reverse the order of the results now:
	if filter.Before {
		filter.Order.Descending = !descending
	}

	r, hasMore, count, err := user.QueryPaginated(ctx, l.pool, filter.Cursor, filter.Where, filter.Order, filter.Count)

	if err != nil {
		return
	}

	// We may need to reverse the order back again if we swapped it:
	if descending != filter.Order.Descending {
		// Restore the order
		for i := len(r)/2 - 1; i >= 0; i-- {
			opp := len(r) - 1 - i
			r[i], r[opp] = r[opp], r[i]
		}
	}

	if filter.Before {
		pi.HasPreviousPage = hasMore
		if filter.Cursor != nil {
			pi.HasNextPage = true
		}
	} else {
		pi.HasNextPage = hasMore
		if filter.Cursor != nil {
			pi.HasPreviousPage = true
		}
	}

	all = make([]user.Row, len(r))
	for i, b := range r {
		all[i] = hydrateModelUser(ctx, b)
	}

	return
}
