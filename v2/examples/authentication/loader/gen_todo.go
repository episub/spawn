// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots
package loader

import (
	"context"
	"fmt"
	"sync"
	"time"

	sq "github.com/Masterminds/squirrel"
	"github.com/example/todo/gnorm"
	"github.com/example/todo/gnorm/public/todo"
	"github.com/example/todo/models"
	opentracing "github.com/opentracing/opentracing-go"
)

// TodoFetchRequest A request for a todo object, to be batched
type TodoFetchRequest struct {
	TodoID int
	Reply  chan TodoFetchReply
}

// TodoFetchReply A reply with the requested object or an error
type TodoFetchReply struct {
	Row   todo.Row
	Error error
}

var todoInitialised bool
var todoFRs []TodoFetchRequest
var todoMX sync.RWMutex

// OneTodo Returns a single Todo with the given where clauses and order
func (l *PostgresLoader) OneTodo(ctx context.Context, where []sq.Sqlizer, order *gnorm.Order) (o todo.Row, err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "OneTodo")
	defer span.Finish()

	r, err := todo.One(ctx, l.pool, where, order)

	o = hydrateModelTodo(ctx, r)

	return o, err
}

// GetTodo Returns Todo with given ID
func (l *PostgresLoader) GetTodo(ctx context.Context, id int) (o todo.Row, err error) {
	return l.getTodo(ctx, id, l.pool)
}

// getTodo Returns Todo with given ID, using provided DB connection
func (l *PostgresLoader) getTodo(ctx context.Context, id int, db gnorm.DB) (o todo.Row, err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "GetTodo")
	defer span.Finish()

	r, err := l.batchedGetTodo(id, l.pool)

	if err != nil {
		err = sanitiseError(err)
		return
	}

	o = hydrateModelTodo(ctx, r)

	return
}

func (l *PostgresLoader) batchedGetTodo(id int, db gnorm.DB) (o todo.Row, err error) {
	todoMX.RLock()
	if !todoInitialised {
		err = fmt.Errorf("batchedGetTodo not initialised.  Add 'go loader.runTodoBatcher()' to init")
	}
	todoMX.RUnlock()
	if err != nil {
		return
	}

	rchan := make(chan TodoFetchReply)
	r := TodoFetchRequest{
		TodoID: id,
		Reply:  rchan,
	}

	todoMX.Lock()
	todoFRs = append(todoFRs, r)
	todoMX.Unlock()

	reply := <-rchan

	return reply.Row, reply.Error
}

func (l *PostgresLoader) runTodoBatcher() {
	todoMX.Lock()
	todoInitialised = true
	todoMX.Unlock()
	for {
		time.Sleep(time.Millisecond * 20)

		todoMX.Lock()
		if len(todoFRs) > 0 {
			var todos []todo.Row
			var err error
			var ids []int

			for _, r := range todoFRs {
				ids = append(ids, r.TodoID)
			}

			todos, err = todo.Query(context.Background(), l.pool, []sq.Sqlizer{gnorm.InInt(todo.TodoIDCol, ids)})

		OUTER:
			for _, r := range todoFRs {
				for _, c := range todos {
					if c.TodoID == r.TodoID {
						r.Reply <- TodoFetchReply{Row: c, Error: nil}
						continue OUTER
					}
				}

				err2 := err

				if err2 == nil {
					err2 = fmt.Errorf("Not found")
				}
				r.Reply <- TodoFetchReply{Error: err2}
			}

			todoFRs = []TodoFetchRequest{}
		}

		todoMX.Unlock()
	}
}

// GetAllTodo Returns an array of all Todo entries, using the provided filter
// For an explanation on how the query works, and reversing orders, etc:
// https://use-the-index-luke.com/sql/partial-results/fetch-next-page
func (l *PostgresLoader) GetAllTodo(ctx context.Context, filter models.Filter) (all []todo.Row, pi models.PageInfo, count int, err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "GetAllTodo")
	defer span.Finish()

	descending := filter.Order.Descending
	// If filter.Before, we reverse the order of the results now:
	if filter.Before {
		filter.Order.Descending = !descending
	}

	r, hasMore, count, err := todo.QueryPaginated(ctx, l.pool, filter.Cursor, filter.Where, filter.Order, filter.Count)

	if err != nil {
		return
	}

	// We may need to reverse the order back again if we swapped it:
	if descending != filter.Order.Descending {
		// Restore the order
		for i := len(r)/2 - 1; i >= 0; i-- {
			opp := len(r) - 1 - i
			r[i], r[opp] = r[opp], r[i]
		}
	}

	if filter.Before {
		pi.HasPreviousPage = hasMore
		if filter.Cursor != nil {
			pi.HasNextPage = true
		}
	} else {
		pi.HasNextPage = hasMore
		if filter.Cursor != nil {
			pi.HasPreviousPage = true
		}
	}

	all = make([]todo.Row, len(r))
	for i, b := range r {
		all[i] = hydrateModelTodo(ctx, b)
	}

	return
}
