// Code generated by gnorm, DO NOT EDIT!
{{$rootPkg := .Params.RootPkg -}}
{{$params := .Params -}}
{{$table := .Table.DBName -}}
{{$schema := .Table.Schema.DBName -}}
{{$hasCreatedAt := ne (len (.Table.Columns.DBNames.Except (makeSlice .Params.CreatedAtField))) (len .Table.Columns.DBNames)}}
{{$hasUpdatedAt := ne (len (.Table.Columns.DBNames.Except (makeSlice .Params.UpdatedAtField))) (len .Table.Columns.DBNames)}}
{{$colsByName := .Table.ColumnsByName }}
{{$childColsByName := false }}
{{$parent := false}} {{/* When there's a child table like _version, this is the parent */}}
{{$child := false}} {{/* When there's a child table like _version, this is the child */}}
{{$parentKey := false}} {{/* When there's a child table like _version, this is the parent table primary key */}}
{{$dot := .}}
{{$tables := makeSlice ""}}

{{- $nonPKDBNames := .Table.Columns.DBNames.Sorted.Except .Table.PrimaryKeys.DBNames}}

{{/* We want a "Full" query for each type.  Just the single table if there's no version table, otherwise a combined Table + TableVersion thing for full/*}}
{{/* If this IS the "_version" table file, we don't generate these fields */}}
{{if hasSuffix (trimSpace .Table.DBName) "_version"}}
{{else}}
	{{if eq (len .Table.PrimaryKeys) 1}}
		{{$child = index .Table.Schema.TablesByName (print .Table.DBName "_version")}}
		{{$parent = .Table}}
		{{$parentKey = (index $parent.PrimaryKeys 0)}}
		{{if $child}}
			{{$childColsByName = $child.ColumnsByName}}
			{{$tables = makeSlice "" "Full"}}
		{{end}}
	{{end}}
{{end}}

package {{toLower .Table.Name}}

import (
	"{{.Params.RootImport}}"
	"{{.Params.RootImport}}/{{toLower .Table.Schema.Name}}/enum"
	{{- if $child}}
	"{{.Params.RootImport}}/{{toLower .Table.Schema.Name}}/{{toLower $child.Name}}"
	{{- end}}
	"github.com/jackc/pgx"
	"github.com/lib/pq"
	"github.com/opentracing/opentracing-go/log"
	"github.com/pkg/errors"
	opentracing "github.com/opentracing/opentracing-go"
	sq "github.com/Masterminds/squirrel"
	uuid "github.com/gofrs/uuid"
)

// TableName is the primary table that this particular gnormed file deals with.
const TableName = "{{.Table.DBName}}"

// Row represents a row from '{{ $table }}'.
type Row struct {
{{- range .Table.PrimaryKeys.DBNames.Sorted }}{{ with (index $colsByName .)}}
	{{ .Name }} {{ if .IsArray }}[]{{ end }}{{ .Type }} `json:"{{.DBName}}"` // {{ .DBName }} (PK){{end}}
{{- end }}
{{- range $nonPKDBNames }}{{ with (index $colsByName .) }}
	{{ .Name }} {{ if .IsArray }}[]{{ end }}{{ .Type }} `json:"{{.DBName}}"` // {{ .DBName }}{{end}}
{{- end }}
}

{{/* Create full row type struct for fetching parent and child */}}
{{if $child}}
// FullRow Full response of joined parent with latest child version
type FullRow struct {
	Parent Row
	{{if $child -}}
	Version {{toLower $child.Name}}.Row
	{{end}}
}
{{end}}

// Field values for every column in {{.Table.Name}}.
var (
{{- range .Table.Columns.DBNames.Sorted }}{{with index $colsByName .}}
	{{.Name}}Col = "{{ .DBName }}"{{end}}
{{- end}}
)

// Scanner Scans the provided row into a Row struct and returns it
func Scanner(row gnorm.Scanner) (Row, error) {
	var r Row
	err := row.Scan(
	{{range .Table.Columns.DBNames.Sorted}}{{with index $colsByName .}}
		{{- if .IsArray }}pq.Array(&r.{{ .Name }}),{{- else -}}&r.{{ .Name }},{{ end }}{{end}}
	{{end -}}
	)

	return r, err
}

{{if $child}}
// FullScanner Scans the provided row into a FullRow struct and returns it
func FullScanner(row gnorm.Scanner) (FullRow, error) {
	var r FullRow
	err := row.Scan(
	{{range .Table.Columns.DBNames.Sorted}}{{with index $colsByName .}}
		{{- if .IsArray }}pq.Array(&r.Parent.{{ .Name }}),{{- else -}}&r.Parent.{{ .Name }},{{ end }}{{end}}
	{{end -}}
	{{range $child.Columns.DBNames.Sorted}}{{with index $childColsByName .}}
		{{- if .IsArray }}pq.Array(&r.Version.{{ .Name }}),{{- else -}}&r.Version.{{ .Name }},{{ end }}{{end}}
	{{end -}}
	)

	return r, err
}
{{end}}

// Select Column and table select values
const Select = `p.{{ join .Table.Columns.DBNames.Sorted ", p." }} FROM {{$schema}}.{{$table}} as p`

{{if $child}}
// FullSelectFields Fields to use for fetching all from parent and child table
const FullSelectFields = `p.{{ join $parent.Columns.DBNames.Sorted ", p." }},
c.{{ join $child.Columns.DBNames.Sorted ", c." }}`

// FullSelect Column and table select values for parent and version child
const FullSelect = `p.{{ join $parent.Columns.DBNames.Sorted ", p." }},
c.{{ join $child.Columns.DBNames.Sorted ", c." }}
FROM {{$schema}}.{{$parent.DBName}} as p
INNER JOIN {{$schema}}.{{$child.DBName}} as c
ON p.{{$parentKey.DBName}} = c.{{$parentKey.DBName}}_{{$parent.DBName}}
AND c.{{snake $params.CreatedAtField}} = 
(
	SELECT Max({{snake $params.CreatedAtField}})
	FROM {{$schema}}.{{$child.DBName}}
	WHERE {{$parentKey.DBName}} = {{$parentKey.DBName}}_{{$parent.DBName}}
)`
{{end}}

{{range $index, $element := $tables}}
// All{{$element}} retrieves all rows from '{{ $table }}' as a slice of Row, joining
// the most recent version entry in
func All{{$element}}(ctx context.Context, db {{$rootPkg}}.DB) ([]{{$element}}Row, error) {
	qry := gnorm.Qry().Select({{$element}}Select)
	sqlstr, _, err := qry.ToSql()
	if err != nil {
		return nil, err
	}

	var vals []{{$element}}Row
	q, err := db.Query(sqlstr)
	if err != nil {
		return nil, errors.Wrap(err, "query {{$dot.Table.Name}}")
	}
	for q.Next() {
		r, err := {{$element}}Scanner(q)
		if err != nil {
			return nil, errors.Wrap(err, "all{{$element}} {{$dot.Table.Name}}")
		}
		vals = append(vals, r)
	}
	return vals, nil
}
{{end}}

// CountQuery retrieve one row from '{{ $table }}'.
func CountQuery(ctx context.Context, db gnorm.DB, where []sq.Sqlizer) (int, error) {
	qry := gnorm.Qry().Select(`count(*) as count`)
	qry = qry.From("{{$schema}}.{{ $table }}")
	for _, w := range where {
		qry = qry.Where(w)
	}

	sqlstr, args, err := qry.ToSql()
	if err != nil {
		return 0, err
	}

	count := 0
	err = db.QueryRow(sqlstr, args...).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "count {{.Table.Name}}")
	}
	return count, nil
}

{{range $index, $element := $tables}}
// Query{{$element}} retrieves rows from '{{ $table }}' as a slice of Row.
func Query{{$element}}(
	ctx context.Context,
	db {{$rootPkg}}.DB,
	where []sq.Sqlizer,
	order *gnorm.Order,
) ([]{{$element}}Row, error) {
	qry := gnorm.Qry().Select({{$element}}Select)
	for _, w := range where {
		qry = qry.Where(w)
	}

	if order != nil {
		qry = qry.OrderBy(order.String())
	}

	sqlstr, args, err := qry.ToSql()
	if err != nil {
		return nil, err
	}

	var vals []{{$element}}Row
	q, err := db.Query(sqlstr, args...)
	if err != nil {
		return nil, errors.Wrap(err, "query{{$element}} query {{$dot.Table.Name}}")
	}
	for q.Next() {
		r, err := {{$element}}Scanner(q)
		if err != nil {
			return nil, errors.Wrap(err, "query{{$element}} {{$dot.Table.Name}}")
		}
		vals = append(vals, r)
	}
	return vals, nil
}
{{end}}

{{if .Table.HasPrimaryKey }}
{{$primaryKey := (index .Table.PrimaryKeys 0)}}
// PaginatedQuery Query used to get paginated results.  Can be replaced with
// a custom query of your own choosing that will allow you to sort or filter
// based on related fields as well
var PaginatedQuery = gnorm.
	Qry().
	Select("p.{{ join .Table.Columns.DBNames.Sorted ", p." }}").
	From("{{$schema}}.{{ $table }} as p")

// QueryPaginated retrieves rows from '{{ .Table.Name }}' as a slice of Row.  If count == 0, then returns all results.  Returns true if there are more results to be had than those listed
// It will first grab a list of the relevant ID's, then fetch the full objects separately.  Done this way so that we can use custom queries that join more rows for use in sorting and filtering.
func QueryPaginated(ctx context.Context, db gnorm.DB, cursor *string, where []sq.Sqlizer, order gnorm.Order, count int64) (vals []Row, hasMore bool, total int, err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "QueryPaginated {{ .Table.Name }}")
	defer span.Finish()

	qry := PaginatedQuery

	for _, w := range where {
		qry = qry.Where(w)
	}

	sqlstr, args, err := qry.ToSql()
	if err != nil {
		return
	}

	// Get the total number of rows possible with our existing query, before we add the cursor related conditional
  countSQL := fmt.Sprintf("SELECT count(*) FROM (%s) AS xyz", sqlstr)
	span.LogFields(
		log.String("countQuery", countSQL),
	)
	err = db.QueryRow(countSQL, args...).Scan(&total)

	if err != nil {
		return
	}

	if cursor != nil {
		w, args := gnorm.PaginateCursorWhere(*cursor, order, sqlstr, "{{$primaryKey.DBName}}")
		qry = qry.Where(w, args...)
	}

	err = order.AddField("{{$primaryKey.DBName}}")
	if err != nil {
		return
	}

	// Order of results:
	qry = qry.OrderBy(order.String())

	if count > 0 {
		qry = qry.Limit(uint64(count) + 1)
	}

	sqlstr, args, err = qry.ToSql()
	if err != nil {
		return
	}

	pageQuery := fmt.Sprintf("SELECT {{$primaryKey.DBName}} FROM (%s) AS xyz", sqlstr)
	span.LogFields(
		log.String("query", pageQuery),
	)
	q, err := db.Query(pageQuery, args...)
	if err != nil {
		return
	}

	// Collect the ID's together, and use them to fetch the full objects.  We do this in two stages because sometimes we will explicitly replace the auto-generated query used for this function, full{{$primaryKey.Name}}PaginatedQuery.  This allows us to use custom queries that are tailored to allow sorting and filtering by fields that may not be available in just the parent and child (version) tables alone.
	var fetchIDs []{{$primaryKey.Type}}
	for q.Next() {
		var r {{$primaryKey.Type}}

		err = q.Scan(&r)
		if err != nil {
			return
		}

		fetchIDs = append(fetchIDs, r)
	}

	if len(fetchIDs) == 0 {
		return
	}

	fetched, err := Query(ctx, db, []sq.Sqlizer{gnorm.In{{pascal $primaryKey.Type}}({{$primaryKey.Name}}Col, fetchIDs)}, nil)

	// Now create vals:
	vals = make([]Row, len(fetchIDs))
	
	found := 0
	for i, id := range fetchIDs {
		for _, v := range fetched {
			if id == v.{{$primaryKey.Name}} {
				vals[i] = v
				found++
				continue
			}
		}
	}

	if found != len(fetchIDs) {
		err = fmt.Errorf("Could not find all required records")
	}

	// If count was more than 0 and we received more results than count, there are more rows to fetch
	if (count > 0 && int64(len(fetchIDs)) > count) {
		hasMore = true
		vals = vals[:len(vals)-1]
	}

	return 
}
{{end}}

{{/* Takes the number of values to produce and produces a list of postgres
placeholders of the form $1, $2, etc */}}
{{- define "values" -}}
	{{$nums := numbers 1 . -}}
	{{$indices := $nums.Sprintf "$%s" -}}
	{{join $indices ", " -}}
{{end}}


{{- $PKFields := join (.Table.PrimaryKeys.Names.Sorted.Sprintf "r.%s") ", "}}
{{- $PKScanFields := join (.Table.PrimaryKeys.Names.Sorted.Sprintf "&r.%s") ", "}}

{{- $numNonPKs := sub (len .Table.Columns) (len .Table.PrimaryKeys)}}


{{if .Table.HasPrimaryKey }}
{{range $index, $element := $tables}}
// Find{{$element}} retrieves a row from '{{ $table }}' by its primary key(s).
func Find{{$element}}(ctx context.Context, db {{$rootPkg}}.DB,
{{- range $parent.PrimaryKeys.DBNames.Sorted}}
	{{- with index $colsByName .}}
	{{camel .DBName}} {{.Type}},{{end}}
{{end -}}) ({{$element}}Row, error) {
	const sqlstr = `SELECT ` + {{$element}}Select + `
	WHERE ( {{join $parent.PrimaryKeys.DBNames.Sorted ", "}} = {{template "values" (len $parent.PrimaryKeys)}} )`

	q := db.QueryRow(sqlstr,
	{{- range $parent.PrimaryKeys.DBNames.Sorted}}
		{{camel .}},
	{{end -}})
	r, err := {{$element}}Scanner(q)
	if err != nil {
		return {{$element}}Row{}, errors.Wrap(err, "find{{$element}} {{$parent.Name}}")
	}
	return r, nil
}
{{end}}
{{end}}

{{if .Table.HasPrimaryKey }}
{{range $index, $element := $tables}}
// One{{$element}} retrieve one row from '{{ $table }}'.
func One{{$element}}(ctx context.Context, db {{$rootPkg}}.DB, where []sq.Sqlizer, order *gnorm.Order) ({{$element}}Row, error) {
	qry := gnorm.Qry().Select({{$element}}Select)

	for _, w := range where {
		qry = qry.Where(w)
	}

	if order != nil {
		qry = qry.OrderBy(order.String())
	}

	qry = qry.Limit(1)

	sqlstr, args, err := qry.ToSql()
	if err != nil {
		return {{$element}}Row{}, err
	}

	q := db.QueryRow(sqlstr, args...)
	r, err := {{$element}}Scanner(q)
	if err != nil {
		return {{$element}}Row{}, errors.Wrap(err, "queryOne{{$element}} {{$parent.Name}}")
	}
	return r, nil
}
{{end}}
{{end}}

// Upsert Creates or updates record based on input
func Upsert(ctx context.Context, db gnorm.DB, o Row) (Row, error) {
	span, _ := opentracing.StartSpanFromContext(ctx, "Upsert_{{.Table.Name}}")
	defer span.Finish()

	var err error
	if err = prepareCreate(ctx, &o); err != nil {
		return o, err
	}

	// sql query
	const sqlstr = `INSERT INTO {{$schema}}.{{$table}} (` +
		`{{ join .Table.Columns.DBNames.Sorted ", " }}` +
		`) VALUES (` +
		{{- $vals := numbers 1 (len .Table.Columns) }}
		`${{ join $vals ", $" }}` +
		`) ON CONFLICT ({{ join .Table.PrimaryKeys.DBNames.Sorted ", " }}) DO UPDATE SET (` +
		`{{ join .Table.Columns.DBNames.Sorted ", " }}` +
		`) = (` +
		`EXCLUDED.{{ join .Table.Columns.DBNames.Sorted ", EXCLUDED." }}` +
		`)`

	// run query
	_, err = db.Exec(sqlstr, o.{{join .Table.Columns.Names.Sorted ", o."}})
	if err != nil {
		return o, err
	}

	return o,nil
}

// BatchInsert Creates provided entries in one attempt
func BatchInsert(ctx context.Context, db gnorm.DB, rows []Row) error {
	span, _ := opentracing.StartSpanFromContext(ctx, "BatchInsert_{{.Table.Name}}")
	defer span.Finish()

	args := make([]interface{}, {{len .Table.Columns}} * len(rows))
	inserts := make([]string, len(rows))

	var err error
	for i, o := range rows {
		if err = prepareCreate(ctx, &o); err != nil {
			return err
		}

		argNumbers := make([]string, {{len .Table.Columns}})

		globalIndex := i * {{len .Table.Columns}}
		index := 0

		// Append the args:
		{{- range $index, $element := .Table.Columns.Names.Sorted}}
		args[globalIndex] = o.{{ $element }}
		fmt.Printf("\nIndex: %d\n", index)
		argNumbers[index] = fmt.Sprintf("%d", globalIndex+1)
		globalIndex++
		index++
		{{end -}}

		// Add the value
		inserts[i] = fmt.Sprintf("($%s)", strings.Join(argNumbers, ", $"))
	}

	// sql query
	var sqlstr = `INSERT INTO {{$schema}}.{{$table}} (` +
		`{{ join .Table.Columns.DBNames.Sorted ", " }}` +
		`) VALUES ` + strings.Join(inserts, ", ")

	fmt.Printf("Query: %s\n", sqlstr)

	// run query
	_, err = db.Exec(sqlstr, args...)
	if err != nil {
		return err
	}

	return nil
}


{{- if $child}}
// UpsertFull Creates or updates record based on input for both parent and
// child record
func UpsertFull(ctx context.Context, db gnorm.DB, o FullRow) (FullRow, error) {
	span, _ := opentracing.StartSpanFromContext(ctx, "UpsertFull_{{.Table.Name}}")
	defer span.Finish()

	var err error

	// Upsert the main record:
	o.Parent, err = Upsert(ctx, db, o.Parent)
	if err != nil {
		return o, err
	}

	// Upsert the child record:
	o.Version, err = {{toLower $child.Name}}.Upsert(ctx, db, o.Version)
	return o, err
}
{{end}}

{{if .Table.HasPrimaryKey }}
// Delete deletes the Row from the database. Returns the number of items deleted.
func Delete( ctx context.Context,
	db {{$rootPkg}}.DB,
{{- range .Table.PrimaryKeys.DBNames.Sorted}}{{with index $colsByName .}}
	{{camel .DBName}} {{.Type}},{{end}}
{{end -}}
) (int64, error) {
	const sqlstr = `DELETE FROM {{$schema}}.{{ $table }} 
	WHERE
	  {{$last := dec (len .Table.PrimaryKeys)}} 
	  {{- range $x, $name := .Table.PrimaryKeys.DBNames.Sorted -}}
		{{$name}} = ${{inc $x}}{{if lt $x $last}} AND {{end}}
	  {{- end}}
	`

	res, err := db.Exec(sqlstr,
	{{- range .Table.PrimaryKeys.DBNames.Sorted -}}
		{{camel .}},
	{{- end -}}
	)
	if err != nil {
		return 0, errors.Wrap(err, "delete {{.Table.Name}}")
	}
	rows := res.RowsAffected()
	return rows, nil
}
{{end}}

// DeleteWhere deletes Rows from the database and returns the number of rows deleted.
func DeleteWhere(ctx context.Context, db {{$rootPkg}}.DB, where []sq.Sqlizer) (int64, error) {
	qry := gnorm.Qry().Delete("")
	qry = qry.From("{{$schema}}.{{ $table }}")
	for _, w := range where {
		qry = qry.Where(w)
	}

	sqlstr, args, err := qry.ToSql()
	if err != nil {
		return 0, err
	}

	res, err := db.Exec(sqlstr, args...)
	if err != nil {
		return 0, errors.Wrap(err, "delete {{.Table.Name}}")
	}
	return res.RowsAffected(), nil
}

// DeleteAll deletes all Rows from the database and returns the number of rows deleted.
func DeleteAll(ctx context.Context, db {{$rootPkg}}.DB) (int64, error) {
	const sqlstr = `DELETE FROM {{$schema}}.{{ $table }}`

	res, err := db.Exec(sqlstr)
	if err != nil {
		return 0, errors.Wrap(err, "deleteall {{.Table.Name}}")
	}
	return res.RowsAffected(), nil
}

// Update Updates with the provided records and condition
func Update(ctx context.Context, db {{$rootPkg}}.DB, updates map[string]interface{}, where []sq.Sqlizer) (int64, error) {
	qry := gnorm.Qry().Update("").Table("{{$schema}}.{{ $table }}")

	{{if $hasUpdatedAt}}
	if _, ok := updates["{{$params.UpdatedAtField}}"]; !ok {
		updates["{{$params.UpdatedAtField}}"] = time.Now()
	}
	{{end}}

	qry = qry.SetMap(updates)
	for _, w := range where {
		qry = qry.Where(w)
	}

	sqlstr, args, err := qry.ToSql()
	if err != nil {
		return 0, err
	}

	res, err := db.Exec(sqlstr, args...)
	if err != nil {
		return 0, errors.Wrap(err, "update {{.Table.Name}}")
	}
	return res.RowsAffected(), nil
}

// prepareCreate Prepares some fields for a new row if they haven't been provided already.  For example, primary key UUID values, created, etc
func prepareCreate(ctx context.Context, o *Row) error {
	span, ctx := opentracing.StartSpanFromContext(ctx, "prepareCreate {{.Table.Name}}")
	defer span.Finish()

	if o == nil {
		return nil
	}

	{{- range $index, $element := .Table.PrimaryKeys}}
	{{if eq $element.DBType "uuid"}}
	// Set Primary Key UUID if not set:
	if o.{{$element.Name}} == uuid.Nil {
		id, err := uuid.NewV4()
		if err != nil {
			return err
		}

		o.{{$element.Name}} = id
	}
	{{end}}
	{{end}}

	{{- range $index, $element := .Table.Columns}}
	{{if eq $element.Name (pascal $params.CreatedAtField)}}
	// Set created time if not set
	if o.{{pascal $params.CreatedAtField}}.IsZero() {
		o.{{pascal $params.CreatedAtField}}= time.Now()
	}
	{{end}}
	{{if eq $element.Name (pascal $params.UpdatedAtField)}}
	// Set updated to now
	o.{{$element.Name}} = time.Now()
	{{end}}
	{{if eq $element.Name "CreatedBy"}}
	// Set CreatedBy if not already set
	if o.CreatedBy == uuid.Nil {
		createdBy, ok := ctx.Value("created_by").(string)

		if !ok {
			return fmt.Errorf("Created by not set, and no 'created_by' value found in context")
		}

		// Check that this is actually a UUID:
		cbid, err := uuid.FromString(createdBy)

		if err != nil {
			return fmt.Errorf("Invalid 'created_by' value found in context")
		}

		o.CreatedBy = cbid
	}
	{{end}}
	{{if eq $element.Name "UpdatedBy"}}
	// Set UpdatedBy to current user
	updatedBy, ok := ctx.Value("created_by").(string)

	if !ok {
		return fmt.Errorf("Updated by not set, and no 'created_by' value found in context")
	}

	// Check that this is actually a UUID:
	ubid, err := uuid.FromString(updatedBy)

	if err != nil {
		return fmt.Errorf("Invalid 'created_by' value found in context")
	}

	o.UpdatedBy = ubid
	{{end}}
	{{end}}

	return nil
}
