// Code generated by gnorm, DO NOT EDIT!

package {{toLower .Table.Name}}

import (
	"{{.Params.RootImport}}"
	"{{.Params.RootImport}}/{{toLower .Table.Schema.Name}}/enum"
	sq "github.com/Masterminds/squirrel"
	uuid "github.com/gofrs/uuid"
	opentracing "github.com/opentracing/opentracing-go"
	"github.com/opentracing/opentracing-go/log"
	"github.com/pkg/errors"
)

// TableName is the primary table that this particular gnormed file deals with.
const TableName = "{{.Table.DBName}}"

{{$rootPkg := .Params.RootPkg -}}
{{$params := .Params -}}
{{$table := .Table.DBName -}}
{{$schema := .Table.Schema.DBName -}}
{{$hasCreatedAt := ne (len (.Table.Columns.DBNames.Except (makeSlice .Params.CreatedAtField))) (len .Table.Columns.DBNames)}}
{{$hasUpdatedAt := ne (len (.Table.Columns.DBNames.Except (makeSlice .Params.UpdatedAtField))) (len .Table.Columns.DBNames)}}
{{$colsByName := .Table.ColumnsByName }}

{{- $nonPKDBNames := .Table.Columns.DBNames.Sorted.Except .Table.PrimaryKeys.DBNames}}


// Row represents a row from '{{ $table }}'.
type Row struct {
{{- range .Table.PrimaryKeys.DBNames.Sorted }}{{ with (index $colsByName .)}}
	{{ .Name }} {{ if .IsArray }}[]{{ end }}{{ .Type }}  // {{ .DBName }} (PK){{end}}
{{- end }}
{{- range $nonPKDBNames }}{{ with (index $colsByName .) }}
	{{ .Name }} {{ if .IsArray }}[]{{ end }}{{ .Type }}  // {{ .DBName }}{{end}}
{{- end }}
}


// Field values for every column in {{.Table.Name}}.
var (
{{- range .Table.Columns.DBNames.Sorted }}{{with index $colsByName .}}
	{{.Name}}Col = "{{ .DBName }}"{{end}}
{{- end}}
)

// All retrieves all rows from '{{ $table }}' as a slice of Row.
func All(ctx context.Context, db {{$rootPkg}}.DB) ([]Row, error) {
	qry := gnorm.Qry().Select(`{{ join .Table.Columns.DBNames.Sorted ", " }}`)
	qry.From(`{{$schema}}.{{$table}}`)
	sqlstr, _, err := qry.ToSql()
	if err != nil {
		return nil, err
	}

	var vals []Row
	q, err := db.Query(sqlstr)
	if err != nil {
		return nil, errors.Wrap(err, "query {{.Table.Name}}")
	}
	for q.Next() {
		r := Row{}
		err := q.Scan({{- range .Table.Columns.DBNames.Sorted}}{{with index $colsByName .}}
		{{- if .IsArray }}pq.Array(&r.{{ .Name }}),{{- else -}}&r.{{ .Name }},{{ end }}{{end}}
{{end -}})
		if err != nil {
			return nil, errors.Wrap(err, "all {{.Table.Name}}")
		}
		vals = append(vals, r)
	}
	return vals, nil
}

// CountQuery retrieve one row from '{{ $table }}'.
func CountQuery(ctx context.Context, db gnorm.DB, where []sq.Sqlizer) (int, error) {
	qry := gnorm.Qry().Select(`count(*) as count`)
	qry = qry.From("{{$schema}}.{{ $table }}")
	for _, w := range where {
		qry = qry.Where(w)
	}

	sqlstr, args, err := qry.ToSql()
	if err != nil {
		return 0, err
	}

	count := 0
	err = db.QueryRow(sqlstr, args...).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "count {{.Table.Name}}")
	}
	return count, nil
}

// Query retrieves rows from '{{ $table }}' as a slice of Row.
func Query(ctx context.Context, db {{$rootPkg}}.DB, where []sq.Sqlizer) ([]Row, error) {
	qry := gnorm.Qry().Select(`{{ join .Table.Columns.DBNames ", " }}`)
	qry = qry.From("{{$schema}}.{{ $table }}")
	for _, w := range where {
		qry = qry.Where(w)
	}

	sqlstr, args, err := qry.ToSql()
	if err != nil {
		return nil, err
	}

	var vals []Row
	q, err := db.Query(sqlstr, args...)
	if err != nil {
		return nil, errors.Wrap(err, "query {{.Table.Name}}")
	}
	for q.Next() {
		r := Row{}
		err := q.Scan({{- range .Table.Columns}}
		{{- if .IsArray }}pq.Array(&r.{{ .Name }}),{{- else -}}&r.{{ .Name }},{{ end }}
{{end -}})
		if err != nil {
			return nil, errors.Wrap(err, "query {{.Table.Name}}")
		}
		vals = append(vals, r)
	}
	return vals, nil
}

{{if .Table.HasPrimaryKey }}
{{$primaryKey := (index .Table.PrimaryKeys 0)}}
// PaginatedQuery Query used to get paginated results.  Can be replaced with
// a custom query of your own choosing that will allow you to sort or filter
// based on related fields as well
var PaginatedQuery = gnorm.
	Qry().
	Select("p.{{ join .Table.Columns.DBNames.Sorted ", p." }}").
	From("{{$schema}}.{{ $table }} as p")

// QueryPaginated retrieves rows from '{{ .Table.Name }}' as a slice of Row.  If count == 0, then returns all results.  Returns true if there are more results to be had than those listed
// It will first grab a list of the relevant ID's, then fetch the full objects separately.  Done this way so that we can use custom queries that join more rows for use in sorting and filtering.
func QueryPaginated(ctx context.Context, db gnorm.DB, cursor *string, where []sq.Sqlizer, order gnorm.Order, count int64) (vals []Row, hasMore bool, total int, err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "QueryPaginated {{ .Table.Name }}")
	defer span.Finish()

	qry := PaginatedQuery

	for _, w := range where {
		qry = qry.Where(w)
	}

	sqlstr, args, err := qry.ToSql()
	if err != nil {
		return
	}

	// Get the total number of rows possible with our existing query, before we add the cursor related conditional
  countSQL := fmt.Sprintf("SELECT count(*) FROM (%s) AS xyz", sqlstr)
	span.LogFields(
		log.String("countQuery", countSQL),
	)
	err = db.QueryRow(countSQL, args...).Scan(&total)

	if err != nil {
		return
	}

	if cursor != nil {
		w, args := gnorm.PaginateCursorWhere(*cursor, order, sqlstr, "{{$primaryKey.DBName}}")
		qry = qry.Where(w, args...)
	}

	err = order.AddField("{{$primaryKey.DBName}}")
	if err != nil {
		return
	}

	// Order of results:
	qry = qry.OrderBy(order.String())

	if count > 0 {
		qry = qry.Limit(uint64(count) + 1)
	}

	sqlstr, args, err = qry.ToSql()
	if err != nil {
		return
	}

	pageQuery := fmt.Sprintf("SELECT {{$primaryKey.DBName}} FROM (%s) AS xyz", sqlstr)
	span.LogFields(
		log.String("query", pageQuery),
	)
	q, err := db.Query(pageQuery, args...)
	if err != nil {
		return
	}

	// Collect the ID's together, and use them to fetch the full objects.  We do this in two stages because sometimes we will explicitly replace the auto-generated query used for this function, full{{$primaryKey.Name}}PaginatedQuery.  This allows us to use custom queries that are tailored to allow sorting and filtering by fields that may not be available in just the parent and child (version) tables alone.
	var fetchIDs []{{$primaryKey.Type}}
	for q.Next() {
		var r {{$primaryKey.Type}}

		err = q.Scan(&r)
		if err != nil {
			return
		}

		fetchIDs = append(fetchIDs, r)
	}

	if len(fetchIDs) == 0 {
		return
	}

	fetched, err := Query(ctx, db, []sq.Sqlizer{gnorm.In{{pascal $primaryKey.Type}}({{$primaryKey.Name}}Col, fetchIDs)})

	// Now create vals:
	vals = make([]Row, len(fetchIDs))
	
	found := 0
	for i, id := range fetchIDs {
		for _, v := range fetched {
			if id == v.{{$primaryKey.Name}} {
				vals[i] = v
				found++
				continue
			}
		}
	}

	if found != len(fetchIDs) {
		err = fmt.Errorf("Could not find all required records")
	}

	// If count was more than 0 and we received more results than count, there are more rows to fetch
	if (count > 0 && int64(len(fetchIDs)) > count) {
		hasMore = true
		vals = vals[:len(vals)-1]
	}

	return 
}
{{end}}

{{/* Takes the number of values to produce and produces a list of postgres
placeholders of the form $1, $2, etc */}}
{{- define "values" -}}
	{{$nums := numbers 1 . -}}
	{{$indices := $nums.Sprintf "$%s" -}}
	{{join $indices ", " -}}
{{end}}


{{- $PKFields := join (.Table.PrimaryKeys.Names.Sorted.Sprintf "r.%s") ", "}}
{{- $PKScanFields := join (.Table.PrimaryKeys.Names.Sorted.Sprintf "&r.%s") ", "}}

{{- $numNonPKs := sub (len .Table.Columns) (len .Table.PrimaryKeys)}}


{{if .Table.HasPrimaryKey }}
// Find retrieves a row from '{{ $table }}' by its primary key(s).
func Find(ctx context.Context, db {{$rootPkg}}.DB,
{{- range .Table.PrimaryKeys.DBNames.Sorted}}
	{{- with index $colsByName .}}
	{{camel .DBName}} {{.Type}},{{end}}
{{end -}}) (Row, error) {
	const sqlstr = `SELECT
		{{ join .Table.Columns.DBNames.Sorted ", " }}
	FROM {{$schema}}.{{ $table }} WHERE ( {{join .Table.PrimaryKeys.DBNames.Sorted ", "}} = {{template "values" (len .Table.PrimaryKeys)}} )`

	r := Row{}
	err := db.QueryRow(sqlstr,
	{{- range .Table.PrimaryKeys.DBNames.Sorted}}
		{{camel .}},
	{{end -}}).Scan({{- range .Table.Columns.DBNames.Sorted}}{{with index $colsByName .}}
		{{- if .IsArray }}pq.Array(&r.{{ .Name }}),{{- else -}}&r.{{ .Name }},{{ end }}{{end}}
{{end -}})
	if err != nil {
		return Row{}, errors.Wrap(err, "find {{.Table.Name}}")
	}
	return r, nil
}
{{end}}

// One retrieve one row from '{{ $table }}'.
func One(ctx context.Context, db {{$rootPkg}}.DB, where []sq.Sqlizer, order *gnorm.Order) (Row, error) {
	qry := gnorm.Qry().Select(`{{ join .Table.Columns.DBNames ", " }}`)
	qry = qry.From("{{$schema}}.{{ $table }}")

	for _, w := range where {
		qry = qry.Where(w)
	}

	if order != nil {
		qry = qry.OrderBy(order.String())
	}

	qry = qry.Limit(1)

	sqlstr, args, err := qry.ToSql()
	if err != nil {
		return Row{}, err
	}

	r := Row{}
	err = db.QueryRow(sqlstr, args...).Scan({{- range .Table.Columns}}
		{{- if .IsArray }}pq.Array(&r.{{ .Name }}),{{- else -}}&r.{{ .Name }},{{ end }}
{{end -}})
	if err != nil {
		return Row{}, errors.Wrap(err, "queryOne {{.Table.Name}}")
	}
	return r, nil
}

// Upsert Creates or updates record based on input
func Upsert(ctx context.Context, db gnorm.DB, o Row) (Row, error) {
	span, _ := opentracing.StartSpanFromContext(ctx, "Upsert{{.Table.Name}}")
	defer span.Finish()

	var err error
	if err = prepareCreate(ctx, &o); err != nil {
		return o, err
	}

	// sql query
	const sqlstr = `INSERT INTO {{$schema}}.{{$table}} (` +
		`{{ join .Table.Columns.DBNames.Sorted ", " }}` +
		`) VALUES (` +
		{{- $vals := numbers 1 (len .Table.Columns) }}
		`${{ join $vals ", $" }}` +
		`) ON CONFLICT ({{ join .Table.PrimaryKeys.DBNames.Sorted ", " }}) DO UPDATE SET (` +
		`{{ join .Table.Columns.DBNames.Sorted ", " }}` +
		`) = (` +
		`EXCLUDED.{{ join .Table.Columns.DBNames.Sorted ", EXCLUDED." }}` +
		`)`

	// run query
	_, err = db.Exec(sqlstr, o.{{join .Table.Columns.Names.Sorted ", o."}})
	if err != nil {
		return o, err
	}

	return o,nil
}

{{if .Table.HasPrimaryKey }}
// Delete deletes the Row from the database. Returns the number of items deleted.
func Delete( ctx context.Context,
	db {{$rootPkg}}.DB,
{{- range .Table.PrimaryKeys.DBNames.Sorted}}{{with index $colsByName .}}
	{{camel .DBName}} {{.Type}},{{end}}
{{end -}}
) (int64, error) {
	const sqlstr = `DELETE FROM {{$schema}}.{{ $table }} 
	WHERE
	  {{$last := dec (len .Table.PrimaryKeys)}} 
	  {{- range $x, $name := .Table.PrimaryKeys.DBNames.Sorted -}}
		{{$name}} = ${{inc $x}}{{if lt $x $last}} AND {{end}}
	  {{- end}}
	`

	res, err := db.Exec(sqlstr,
	{{- range .Table.PrimaryKeys.DBNames.Sorted -}}
		{{camel .}},
	{{- end -}}
	)
	if err != nil {
		return 0, errors.Wrap(err, "delete {{.Table.Name}}")
	}
	rows := res.RowsAffected()
	return rows, nil
}
{{end}}

// DeleteWhere deletes Rows from the database and returns the number of rows deleted.
func DeleteWhere(ctx context.Context, db {{$rootPkg}}.DB, where []sq.Sqlizer) (int64, error) {
	qry := gnorm.Qry().Delete("")
	qry = qry.From("{{$schema}}.{{ $table }}")
	for _, w := range where {
		qry = qry.Where(w)
	}

	sqlstr, args, err := qry.ToSql()
	if err != nil {
		return 0, err
	}

	res, err := db.Exec(sqlstr, args...)
	if err != nil {
		return 0, errors.Wrap(err, "delete {{.Table.Name}}")
	}
	return res.RowsAffected(), nil
}

// DeleteAll deletes all Rows from the database and returns the number of rows deleted.
func DeleteAll(ctx context.Context, db {{$rootPkg}}.DB) (int64, error) {
	const sqlstr = `DELETE FROM {{$schema}}.{{ $table }}`

	res, err := db.Exec(sqlstr)
	if err != nil {
		return 0, errors.Wrap(err, "deleteall {{.Table.Name}}")
	}
	return res.RowsAffected(), nil
}

// Update Updates with the provided records and condition
func Update(ctx context.Context, db {{$rootPkg}}.DB, updates map[string]interface{}, where []sq.Sqlizer) (int64, error) {
	qry := gnorm.Qry().Update("").Table("{{$schema}}.{{ $table }}")

	{{if $hasUpdatedAt}}
	if _, ok := updates["{{$params.UpdatedAtField}}"]; !ok {
		updates["{{$params.UpdatedAtField}}"] = time.Now()
	}
	{{end}}

	qry = qry.SetMap(updates)
	for _, w := range where {
		qry = qry.Where(w)
	}

	sqlstr, args, err := qry.ToSql()
	if err != nil {
		return 0, err
	}

	res, err := db.Exec(sqlstr, args...)
	if err != nil {
		return 0, errors.Wrap(err, "update {{.Table.Name}}")
	}
	return res.RowsAffected(), nil
}

// prepareCreate Prepares some fields for a new row if they haven't been provided already.  For example, primary key UUID values, created, etc
func prepareCreate(ctx context.Context, o *Row) error {
	span, ctx := opentracing.StartSpanFromContext(ctx, "prepareCreate {{.Table.Name}}")
	defer span.Finish()

	if o == nil {
		return nil
	}

	{{- range $index, $element := .Table.PrimaryKeys}}
	{{if eq $element.DBType "uuid"}}
	// Set Primary Key UUID if not set:
	if o.{{$element.Name}} == uuid.Nil {
		id, err := uuid.NewV4()
		if err != nil {
			return err
		}

		o.{{$element.Name}} = id
	}
	{{end}}
	{{end}}

	{{- range $index, $element := .Table.Columns}}
	{{if eq $element.Name (pascal $params.CreatedAtField)}}
	// Set created time if not set
	if o.{{pascal $params.CreatedAtField}}.IsZero() {
		o.{{pascal $params.CreatedAtField}}= time.Now()
	}
	{{end}}
	{{if eq $element.Name (pascal $params.UpdatedAtField)}}
	// Set updated to now
	o.{{$element.Name}} = time.Now()
	{{end}}
	{{if eq $element.Name "CreatedBy"}}
	// Set CreatedBy if not already set
	if len(o.CreatedBy) == 0 {
		createdBy, ok := ctx.Value("created_by").(string)

		if !ok {
			return fmt.Errorf("Created by not set, and no 'created_by' value found in context")
		}

		// Check that this is actually a UUID:
		_, err := uuid.FromString(createdBy)

		if err != nil {
			return fmt.Errorf("Invalid 'created_by' value found in context")
		}

		o.CreatedBy = createdBy
	}
	{{end}}
	{{if eq $element.Name "UpdatedBy"}}
	// Set UpdatedBy to current user
	updatedBy, ok := ctx.Value("created_by").(string)

	if !ok {
		return fmt.Errorf("Updated by by not set, and no 'created_by' value found in context")
	}

	// Check that this is actually a UUID:
	_, err := uuid.FromString(updatedBy)

	if err != nil {
		return fmt.Errorf("Invalid 'created_by' value found in context")
	}

	o.UpdatedBy = updatedBy
	{{end}}
	{{if eq $element.DBName (printf "short_%s_id" $table)}}
	// If no short client ID is given, we select the first 10 characters of the uuid id
	if len(o.ShortClientID) == 0 {
		o.{{.Name}} = strings.Replace(o.ClientID, "-", "", -1)[:10]
	}
	{{end}}
	{{end}}

	return nil
}
