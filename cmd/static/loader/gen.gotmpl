// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots

package loader

{{- $package := toLower .ModelName}}
{{- $struct := printf "%s.Row" $package}}
{{- $fullStr := ""}}
{{if .Versioned}}
	{{$fullStr = "Full"}}
{{end}}

import (
	"{{.Config.PackageName}}/models"
	"{{.Config.PackageName}}/gnorm"
	"{{.Config.PackageName}}/gnorm/{{.Config.Generate.SchemaName}}/{{$package}}"
	"{{.ModelPackage}}"
	sq "github.com/Masterminds/squirrel"
	"github.com/episub/spawn/validate"
	"github.com/gofrs/uuid"
	"github.com/codemodus/kace"
	opentracing "github.com/opentracing/opentracing-go"
)

// {{.ModelName}}FetchRequest A request for a {{camel .ModelName}} object, to be batched
type {{.ModelName}}FetchRequest struct {
	{{.ModelName}}ID {{.PrimaryKeyType}}
	Reply    chan {{.ModelName}}FetchReply
}

// {{.ModelName}}FetchReply A reply with the requested object or an error
type {{.ModelName}}FetchReply struct {
	Row {{$package}}.{{$fullStr}}Row
	Error  error
}

var {{camel .ModelName}}Initialised bool
var {{camel .ModelName}}FRs []{{.ModelName}}FetchRequest
var {{camel .ModelName}}MX sync.RWMutex

// One{{.ModelName}} Returns a single {{.ModelName}} with the given where clauses and order
func (l *PostgresLoader) One{{.ModelName}}(ctx context.Context, where []sq.Sqlizer, order *gnorm.Order) (o {{.ModelStruct}}, err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "One{{.ModelName}}")
	defer span.Finish()

	r, err := {{$package}}.One{{$fullStr}}(ctx, l.pool, where, order)
	
	if err != nil {
		return o, sanitiseError(err)
	}

	o, err = hydrateModel{{.ModelName}}(ctx, l.pool, r)

	return o, sanitiseError(err)
}

// Query{{.ModelName}} Returns array of {{.ModelName}} based on provided
// query conditions
func (l *PostgresLoader) Query{{.ModelName}}(
	ctx context.Context,
	where []sq.Sqlizer,
	order gnorm.Order,
) (models []{{.ModelStruct}}, err error) {
	rows, err := {{$package}}.Query{{$fullStr}}(ctx, l.pool, where, &order)

	if err != nil {
		return
	}

	models, err = hydrate{{.ModelName}}Rows(ctx, l.pool, rows)

	return models, err
}

func hydrate{{.ModelName}}Rows(
	ctx context.Context,
	db gnorm.DB,
	rows []{{$package}}.{{$fullStr}}Row,
) ([]{{.ModelStruct}}, error) {
	reply := make([]{{.ModelStruct}}, len(rows))

	var err error
	for i, row := range rows {
		reply[i], err = hydrateModel{{.ModelName}}(ctx, db, row)
		if err != nil {
			return reply, err
		}
	}

	return reply, nil
}

// Get{{.ModelName}} Returns {{.ModelName}} with given ID
{{- $idName := snake .ModelName}}
func (l *PostgresLoader) Get{{.ModelName}}(ctx context.Context, id {{.PrimaryKeyType}}) (o {{.ModelStruct}}, err error) {
	return l.get{{.ModelName}}(ctx, id, l.pool)
}

// get{{.ModelName}} Returns {{.ModelName}} with given ID, using provided DB connection
func (l *PostgresLoader) get{{.ModelName}}(ctx context.Context, id {{.PrimaryKeyType}}, db gnorm.DB) (o {{.ModelStruct}}, err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "Get{{.ModelName}}")
	defer span.Finish()

	r, err := l.batchedGet{{.PmName}}(id, l.pool)

	if err != nil {
		err = sanitiseError(err)
		return
	}

	o, err = hydrateModel{{.ModelName}}(ctx, db, r)

	return
}

func (l *PostgresLoader) batchedGet{{.ModelName}}(id {{.PrimaryKeyType}}, db gnorm.DB) (o {{$package}}.{{$fullStr}}Row, err error) {
	{{camel .ModelName}}MX.RLock()
	if !{{camel .ModelName}}Initialised {
		err = fmt.Errorf("batchedGet{{.ModelName}} not initialised.  Add 'go loader.run{{.ModelName}}Batcher()' to init")
	}
	{{camel .ModelName}}MX.RUnlock()
	if err != nil {
		return
	}

	rchan := make(chan {{.ModelName}}FetchReply)
	r := {{.ModelName}}FetchRequest{
		{{.ModelName}}ID: id,
		Reply:    rchan,
	}

	{{camel .ModelName}}MX.Lock()
	{{camel .ModelName}}FRs = append({{camel .ModelName}}FRs, r)
	{{camel .ModelName}}MX.Unlock()

	reply := <-rchan

	return reply.Row, reply.Error
}

func (l *PostgresLoader) run{{.ModelName}}Batcher() {
	{{camel .ModelName}}MX.Lock()
	{{camel .ModelName}}Initialised = true
	{{camel .ModelName}}MX.Unlock()
	for {
		time.Sleep(time.Millisecond * 20)

		{{camel .ModelName}}MX.Lock()
		if len({{camel .ModelName}}FRs) > 0 {
			var {{camel .ModelName}}s []{{$package}}.{{$fullStr}}Row
			var err error
			var ids []{{.PrimaryKeyType}}

			for _, r := range {{camel .ModelName}}FRs {
				ids = append(ids, r.{{.ModelName}}ID)
			}

			{{camel .ModelName}}s, err = {{$package}}.Query{{$fullStr}}(context.Background(), l.pool, []sq.Sqlizer{gnorm.In{{pascal .PrimaryKeyType}}({{$package}}.{{.PK}}Col, ids)}, nil)

		OUTER:
			for _, r := range {{camel .ModelName}}FRs {
				for _, c := range {{camel .ModelName}}s {
					
					if c.{{if .Versioned}}Parent.{{end}}{{.ModelName}}ID == r.{{.ModelName}}ID {
						r.Reply <- {{.ModelName}}FetchReply{ Row: c, Error: nil}
						continue OUTER
					}
				}

				err2 := err

				if err2 == nil {
					err2 = fmt.Errorf("Not found")
				}
				r.Reply <- {{.ModelName}}FetchReply{Error: err2}
			}

			{{camel .ModelName}}FRs = []{{.ModelName}}FetchRequest{}
		}

		{{camel .ModelName}}MX.Unlock()
	}
}

{{if .Versioned}}
{{else}}
// GetAll{{.ModelName}} Returns an array of all {{.ModelName}} entries, using the provided filter
// For an explanation on how the query works, and reversing orders, etc:
// https://use-the-index-luke.com/sql/partial-results/fetch-next-page
func (l *PostgresLoader) GetAll{{.ModelName}}(ctx context.Context, filter models.Filter) (all []{{.ModelStruct}}, pi models.PageInfo, count int, err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "GetAll{{.ModelName}}")
	defer span.Finish()

	descending := filter.Order.Descending
	// If filter.Before, we reverse the order of the results now:
	if filter.Before {
		filter.Order.Descending = !descending
	}

	r, hasMore, count, err := {{$package}}.QueryPaginated(ctx, l.pool, filter.Cursor, filter.Where, filter.Order, filter.Count)

	if err != nil {
		return
	}

	// We may need to reverse the order back again if we swapped it:
	if descending != filter.Order.Descending {
		// Restore the order
		for i := len(r)/2 - 1; i >= 0; i-- {
			opp := len(r) - 1 - i
			r[i], r[opp] = r[opp], r[i]
		}
	}

	if filter.Before {
		pi.HasPreviousPage = hasMore
		if filter.Cursor != nil {
			pi.HasNextPage = true
		}
	} else {
		pi.HasNextPage = hasMore
		if filter.Cursor != nil {
			pi.HasPreviousPage = true
		}
	}


	all = make([]{{.ModelStruct}}, len(r))
	for i, b := range r {
		all[i], err = hydrateModel{{.ModelName}}(ctx, l.pool, b)
		if err != nil {
			err = sanitiseError(err)
			return
		}
	}

	return
}
{{end}}

{{if .Create}}
// Update{{.ModelName}} Updates {{.ModelName}} based on provided changes
func (l *PostgresLoader) Update{{.ModelName}}(ctx context.Context, id {{.PrimaryKeyType}}, u map[string]interface{}) error {
	tx, err := l.pool.Begin()

	if err != nil {
		return err
	}

	err = l.update{{.ModelName}}(ctx, tx, id, u)
	if gnorm.RollbackErr(err, tx) != nil {
		return err
	}

	return tx.Commit()
}

// update{{.ModelName}} Updates {{.ModelName}} based on provided changes using provided db connection
func (l *PostgresLoader) update{{.ModelName}}(ctx context.Context, db gnorm.DB, id {{.PrimaryKeyType}}, u map[string]interface{}) error {
	o, err := {{$package}}.Find{{$fullStr}}(ctx, l.pool, id)

	if err != nil {
		return err
	}

	{{if .Versioned}}
	// Nullify the version ID so we ensure a new version entry is created each
	// time:
	o.Version.{{.ModelName}}VersionID = uuid.Nil
	{{end}}

	// Helps us keep track of which field has any errors
	pathCtx := addPathToContext(ctx, kace.Snake("{{.ModelName}}"))

	// By iterating over the map entries, we can ensure we only modify those values that are set:
	for k, v := range u {
		err = l.update{{.ModelName}}Field(pathCtx, false, db, &o, k, v)

		if err != nil {
			return fmt.Errorf("%s: %s", k, err)
		}
	}

	l.validate{{.PmName}}(pathCtx, o)

	if validate.HasErrors(ctx) {
		log.Print("Found validation errors in update{{.ModelName}}")

		// Only return an error if this is top path:
		if isTopPath(ctx) {
			log.Printf("Validation errors: %s", validate.ErrorsString(ctx))
			return fmt.Errorf("Unresolved validation errors, cannot complete action")
		}
		return nil
	}

	_, err = {{$package}}.Upsert{{$fullStr}}(ctx, db, o)

	return sanitiseError(err)
}

// create{{.PmName}} Creates {{.PmName}} from given input
func (l *PostgresLoader) create{{.PmName}}(ctx context.Context, db gnorm.DB, i map[string]interface{}) (o {{$package}}.{{$fullStr}}Row, err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "create{{.PmName}}")
	defer span.Finish()

	// Helps us keep track of which field has any errors
	pathCtx := addPathToContext(ctx, kace.Snake("{{.ModelName}}"))

	for k, v := range i {
		err = l.update{{.ModelName}}Field(pathCtx, true, db, &o, k, v)

		if err != nil {
			err = fmt.Errorf("%s: %s", k, err)
			return
		}
	}

	l.validate{{.PmName}}(pathCtx, o)

	if validate.HasErrors(ctx) {
		log.Print("Found validation errors in create{{.PmName}}")
		if isTopPath(ctx) {
			log.Printf("Validation errors: %s", validate.ErrorsString(ctx))
			return o, fmt.Errorf("Unresolved validation errors, cannot complete action")
		}
		return o, nil
	}

	o, err = {{$package}}.Upsert{{$fullStr}}(ctx, db, o)

	return o, sanitiseError(err)
}
{{end}}
