// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots
package resolvers

import (
	"{{.Config.PackageName}}/models"
	"{{.Config.PackageName}}/loader"
	"{{.Config.PackageName}}/gnorm"
	"github.com/episub/spawn/opa"
	"github.com/99designs/gqlgen/graphql"
	sq "github.com/Masterminds/squirrel"
	"github.com/vektah/gqlparser/gqlerror"
	"github.com/gofrs/uuid"
	opentracing "github.com/opentracing/opentracing-go"
)

func (r *queryResolver) EditableUpdate{{.ModelName}}Fields(ctx context.Context, id string) ([]string, error) {
	return editableUpdate{{.ModelName}}Fields(ctx, id)
}

{{if .Update}}
// Update{{.ModelName}} Updates {{.ModelName}} with provided input
func (r *mutationResolver) Update{{.ModelName}}(ctx context.Context, id string, u map[string]interface{}) (*models.{{.ModelName}}, error) {
	// Get allowed edit fields:
	allowed, err := editableUpdate{{.ModelName}}Fields(ctx, id)
	if err != nil {
		return nil, err
	}

	// Filter out unapproved changes
	changes, _, any, err := authorisedChanges(ctx, allowed, u)

	if err != nil {
		return nil, err
	}

	if !any {
		return nil, fmt.Errorf("No fields were permitted to be updated")
	}

	err = loader.Loader.Update{{.ModelName}}(ctx, id, changes)

	if err != nil {
		return nil, err
	}

	obj, err := loader.Loader.Get{{.ModelName}}(ctx, id)

	return &obj, err
}
{{end}}
{{if .PrepareCreate}}
// prepareCreate{{.ModelName}} Performs some pre-processing on the provided map.  Disable generation of this function and create your own if you require any pre-processing performed
func prepareCreate{{.ModelName}}(ctx context.Context, i map[string]interface{}) error {
	return nil
}
{{end}}
{{if .Create}}
// Create{{.ModelName}} Creates {{.ModelName}}
func (r *mutationResolver) Create{{.ModelName}}(ctx context.Context, i map[string]interface{}) (*models.{{.ModelName}}, error) {
	err := prepareCreate{{.ModelName}}(ctx, i)
	if err != nil {
		return nil, err
	}

	id, err := loader.Loader.Create{{.ModelName}}(ctx, i)

	if err != nil {
		return nil, err
	}

	obj, err := loader.Loader.Get{{.ModelName}}(ctx, id)
	return &obj, err
}
{{end}}
{{if .Query}}
func query{{.PluralModelName}}(ctx context.Context, first *int, after *string, last *int, before *string, cf *models.{{.ModelName}}Filter, sortField *models.{{.ModelName}}Sort, sortDirection *models.SortDirection, where []sq.Sqlizer) (o models.{{.PluralModelName}}Connection, err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "query{{.PluralModelName}}")
	defer span.Finish()

	f := models.NewFilter(first, after, last, before, sortDirection)

	// Set up the sort order based on inputs:
	if sortField != nil {
		var err error

		f.Order, err = sort{{.ModelName}}(ctx, *sortField, f.Order)

		if err != nil {
			return o, fmt.Errorf("Cannot sort by field %s: %s", sortField, err)
		}
	}

	// Configure the where clauses:
	if cf != nil {
		var fw []sq.Sqlizer
		fw, err = filter{{.ModelName}}(ctx, *cf)
		if err != nil {
			return
		}

		where = append(where, fw...)
	}

	f.Where = where

	r, pi, count, err := loader.Loader.GetAll{{.ModelName}}(ctx, f)

	if err != nil {
		return o, err
	}

	o.PageInfo = &pi
	o.TotalCount = count
	o.Edges = make([]*models.{{.ModelName}}Edge, len(r))

	for i, t := range r {
		node := t
		var edge models.{{.ModelName}}Edge
		{{if eq .PrimaryKeyType "string"}}
		edge = models.{{.ModelName}}Edge{Cursor: node.{{.PrimaryKey}}, Node: &node}
		{{else if eq .PrimaryKeyType "int"}}
		edge = models.{{.ModelName}}Edge{Cursor: fmt.Sprintf("%d", node.{{.PrimaryKey}}), Node: &node}
		{{else if eq .PrimaryKeyType "uuid.UUID"}}
		edge = models.{{.ModelName}}Edge{Cursor: node.{{.PrimaryKey}}.String(), Node: &node}
		{{else}}
		panic("Primary key type {{.PrimaryKeyType}} not supported yet")
		{{end}}
		o.Edges[i] = &edge
	}

	o.PageInfo.EndCursor = &o.Edges[len(o.Edges) - 1].Cursor
	o.PageInfo.StartCursor = &o.Edges[0].Cursor

	return o, err
}
{{end}}
