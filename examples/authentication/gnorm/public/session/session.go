// Code generated by gnorm, DO NOT EDIT!

package session

import (
	"context"
	"fmt"
	"time"

	sq "github.com/Masterminds/squirrel"
	"github.com/example/todo/gnorm"
	uuid "github.com/gofrs/uuid"
	opentracing "github.com/opentracing/opentracing-go"
	"github.com/opentracing/opentracing-go/log"
	"github.com/pkg/errors"
)

// TableName is the primary table that this particular gnormed file deals with.
const TableName = "session"

// Row represents a row from 'session'.
type Row struct {
	SessionID uuid.UUID // session_id (PK)
	CreatedAt time.Time // created_at
	Expires   time.Time // expires
	UpdatedAt time.Time // updated_at
	UserID    int       // user_id
}

// Field values for every column in Session.
var (
	CreatedAtCol = "created_at"
	ExpiresCol   = "expires"
	SessionIDCol = "session_id"
	UpdatedAtCol = "updated_at"
	UserIDCol    = "user_id"
)

// All retrieves all rows from 'session' as a slice of Row.
func All(ctx context.Context, db gnorm.DB) ([]Row, error) {
	qry := gnorm.Qry().Select(`created_at, expires, session_id, updated_at, user_id`)
	qry.From(`public.session`)
	sqlstr, _, err := qry.ToSql()
	if err != nil {
		return nil, err
	}

	var vals []Row
	q, err := db.Query(sqlstr)
	if err != nil {
		return nil, errors.Wrap(err, "query Session")
	}
	for q.Next() {
		r := Row{}
		err := q.Scan(
			&r.CreatedAt,
			&r.Expires,
			&r.SessionID,
			&r.UpdatedAt,
			&r.UserID,
		)
		if err != nil {
			return nil, errors.Wrap(err, "all Session")
		}
		vals = append(vals, r)
	}
	return vals, nil
}

// CountQuery retrieve one row from 'session'.
func CountQuery(ctx context.Context, db gnorm.DB, where []sq.Sqlizer) (int, error) {
	qry := gnorm.Qry().Select(`count(*) as count`)
	qry = qry.From("public.session")
	for _, w := range where {
		qry = qry.Where(w)
	}

	sqlstr, args, err := qry.ToSql()
	if err != nil {
		return 0, err
	}

	count := 0
	err = db.QueryRow(sqlstr, args...).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "count Session")
	}
	return count, nil
}

// Query retrieves rows from 'session' as a slice of Row.
func Query(ctx context.Context, db gnorm.DB, where []sq.Sqlizer) ([]Row, error) {
	qry := gnorm.Qry().Select(`session_id, expires, user_id, created_at, updated_at`)
	qry = qry.From("public.session")
	for _, w := range where {
		qry = qry.Where(w)
	}

	sqlstr, args, err := qry.ToSql()
	if err != nil {
		return nil, err
	}

	var vals []Row
	q, err := db.Query(sqlstr, args...)
	if err != nil {
		return nil, errors.Wrap(err, "query Session")
	}
	for q.Next() {
		r := Row{}
		err := q.Scan(
			&r.SessionID,
			&r.Expires,
			&r.UserID,
			&r.CreatedAt,
			&r.UpdatedAt,
		)
		if err != nil {
			return nil, errors.Wrap(err, "query Session")
		}
		vals = append(vals, r)
	}
	return vals, nil
}

// PaginatedQuery Query used to get paginated results.  Can be replaced with
// a custom query of your own choosing that will allow you to sort or filter
// based on related fields as well
var PaginatedQuery = gnorm.
	Qry().
	Select("p.created_at, p.expires, p.session_id, p.updated_at, p.user_id").
	From("public.session as p")

// QueryPaginated retrieves rows from 'Session' as a slice of Row.  If count == 0, then returns all results.  Returns true if there are more results to be had than those listed
// It will first grab a list of the relevant ID's, then fetch the full objects separately.  Done this way so that we can use custom queries that join more rows for use in sorting and filtering.
func QueryPaginated(ctx context.Context, db gnorm.DB, cursor *string, where []sq.Sqlizer, order gnorm.Order, count int64) (vals []Row, hasMore bool, total int, err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "QueryPaginated Session")
	defer span.Finish()

	qry := PaginatedQuery

	for _, w := range where {
		qry = qry.Where(w)
	}

	sqlstr, args, err := qry.ToSql()
	if err != nil {
		return
	}

	// Get the total number of rows possible with our existing query, before we add the cursor related conditional
	countSQL := fmt.Sprintf("SELECT count(*) FROM (%s) AS xyz", sqlstr)
	span.LogFields(
		log.String("countQuery", countSQL),
	)
	err = db.QueryRow(countSQL, args...).Scan(&total)

	if err != nil {
		return
	}

	if cursor != nil {
		w, args := gnorm.PaginateCursorWhere(*cursor, order, sqlstr, "session_id")
		qry = qry.Where(w, args...)
	}

	err = order.AddField("session_id")
	if err != nil {
		return
	}

	// Order of results:
	qry = qry.OrderBy(order.String())

	if count > 0 {
		qry = qry.Limit(uint64(count) + 1)
	}

	sqlstr, args, err = qry.ToSql()
	if err != nil {
		return
	}

	pageQuery := fmt.Sprintf("SELECT session_id FROM (%s) AS xyz", sqlstr)
	span.LogFields(
		log.String("query", pageQuery),
	)
	q, err := db.Query(pageQuery, args...)
	if err != nil {
		return
	}

	// Collect the ID's together, and use them to fetch the full objects.  We do this in two stages because sometimes we will explicitly replace the auto-generated query used for this function, fullSessionIDPaginatedQuery.  This allows us to use custom queries that are tailored to allow sorting and filtering by fields that may not be available in just the parent and child (version) tables alone.
	var fetchIDs []uuid.UUID
	for q.Next() {
		var r uuid.UUID

		err = q.Scan(&r)
		if err != nil {
			return
		}

		fetchIDs = append(fetchIDs, r)
	}

	if len(fetchIDs) == 0 {
		return
	}

	fetched, err := Query(ctx, db, []sq.Sqlizer{gnorm.InUUIDUUID(SessionIDCol, fetchIDs)})

	// Now create vals:
	vals = make([]Row, len(fetchIDs))

	found := 0
	for i, id := range fetchIDs {
		for _, v := range fetched {
			if id == v.SessionID {
				vals[i] = v
				found++
				continue
			}
		}
	}

	if found != len(fetchIDs) {
		err = fmt.Errorf("Could not find all required records")
	}

	// If count was more than 0 and we received more results than count, there are more rows to fetch
	if count > 0 && int64(len(fetchIDs)) > count {
		hasMore = true
		vals = vals[:len(vals)-1]
	}

	return
}

// Find retrieves a row from 'session' by its primary key(s).
func Find(ctx context.Context, db gnorm.DB,
	sessionID uuid.UUID,
) (Row, error) {
	const sqlstr = `SELECT
		created_at, expires, session_id, updated_at, user_id
	FROM public.session WHERE ( session_id = $1 )`

	r := Row{}
	err := db.QueryRow(sqlstr,
		sessionID,
	).Scan(&r.CreatedAt,
		&r.Expires,
		&r.SessionID,
		&r.UpdatedAt,
		&r.UserID,
	)
	if err != nil {
		return Row{}, errors.Wrap(err, "find Session")
	}
	return r, nil
}

// One retrieve one row from 'session'.
func One(ctx context.Context, db gnorm.DB, where []sq.Sqlizer, order *gnorm.Order) (Row, error) {
	qry := gnorm.Qry().Select(`session_id, expires, user_id, created_at, updated_at`)
	qry = qry.From("public.session")

	for _, w := range where {
		qry = qry.Where(w)
	}

	if order != nil {
		qry = qry.OrderBy(order.String())
	}

	qry = qry.Limit(1)

	sqlstr, args, err := qry.ToSql()
	if err != nil {
		return Row{}, err
	}

	r := Row{}
	err = db.QueryRow(sqlstr, args...).Scan(&r.SessionID,
		&r.Expires,
		&r.UserID,
		&r.CreatedAt,
		&r.UpdatedAt,
	)
	if err != nil {
		return Row{}, errors.Wrap(err, "queryOne Session")
	}
	return r, nil
}

// Upsert Creates or updates record based on input
func Upsert(ctx context.Context, db gnorm.DB, o Row) (Row, error) {
	span, _ := opentracing.StartSpanFromContext(ctx, "UpsertSession")
	defer span.Finish()

	var err error
	if err = prepareCreate(ctx, &o); err != nil {
		return o, err
	}

	// sql query
	const sqlstr = `INSERT INTO public.session (` +
		`created_at, expires, session_id, updated_at, user_id` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5` +
		`) ON CONFLICT (session_id) DO UPDATE SET (` +
		`created_at, expires, session_id, updated_at, user_id` +
		`) = (` +
		`EXCLUDED.created_at, EXCLUDED.expires, EXCLUDED.session_id, EXCLUDED.updated_at, EXCLUDED.user_id` +
		`)`

	// run query
	_, err = db.Exec(sqlstr, o.CreatedAt, o.Expires, o.SessionID, o.UpdatedAt, o.UserID)
	if err != nil {
		return o, err
	}

	return o, nil
}

// Delete deletes the Row from the database. Returns the number of items deleted.
func Delete(ctx context.Context,
	db gnorm.DB,
	sessionID uuid.UUID,
) (int64, error) {
	const sqlstr = `DELETE FROM public.session 
	WHERE
	  session_id = $1
	`

	res, err := db.Exec(sqlstr, sessionID)
	if err != nil {
		return 0, errors.Wrap(err, "delete Session")
	}
	rows := res.RowsAffected()
	return rows, nil
}

// DeleteWhere deletes Rows from the database and returns the number of rows deleted.
func DeleteWhere(ctx context.Context, db gnorm.DB, where []sq.Sqlizer) (int64, error) {
	qry := gnorm.Qry().Delete("")
	qry = qry.From("public.session")
	for _, w := range where {
		qry = qry.Where(w)
	}

	sqlstr, args, err := qry.ToSql()
	if err != nil {
		return 0, err
	}

	res, err := db.Exec(sqlstr, args...)
	if err != nil {
		return 0, errors.Wrap(err, "delete Session")
	}
	return res.RowsAffected(), nil
}

// DeleteAll deletes all Rows from the database and returns the number of rows deleted.
func DeleteAll(ctx context.Context, db gnorm.DB) (int64, error) {
	const sqlstr = `DELETE FROM public.session`

	res, err := db.Exec(sqlstr)
	if err != nil {
		return 0, errors.Wrap(err, "deleteall Session")
	}
	return res.RowsAffected(), nil
}

// Update Updates with the provided records and condition
func Update(ctx context.Context, db gnorm.DB, updates map[string]interface{}, where []sq.Sqlizer) (int64, error) {
	qry := gnorm.Qry().Update("").Table("public.session")

	if _, ok := updates["updated_at"]; !ok {
		updates["updated_at"] = time.Now()
	}

	qry = qry.SetMap(updates)
	for _, w := range where {
		qry = qry.Where(w)
	}

	sqlstr, args, err := qry.ToSql()
	if err != nil {
		return 0, err
	}

	res, err := db.Exec(sqlstr, args...)
	if err != nil {
		return 0, errors.Wrap(err, "update Session")
	}
	return res.RowsAffected(), nil
}

// prepareCreate Prepares some fields for a new row if they haven't been provided already.  For example, primary key UUID values, created, etc
func prepareCreate(ctx context.Context, o *Row) error {
	span, ctx := opentracing.StartSpanFromContext(ctx, "prepareCreate Session")
	defer span.Finish()

	if o == nil {
		return nil
	}

	// Set Primary Key UUID if not set:
	if o.SessionID == uuid.Nil {
		id, err := uuid.NewV4()
		if err != nil {
			return err
		}

		o.SessionID = id
	}

	// Set created time if not set
	if o.CreatedAt.IsZero() {
		o.CreatedAt = time.Now()
	}

	// Set updated to now
	o.UpdatedAt = time.Now()

	return nil
}
