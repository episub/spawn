// Code generated by gnorm, DO NOT EDIT!

package user

import (
	"context"
	"fmt"
	"time"

	sq "github.com/Masterminds/squirrel"
	"github.com/example/todo/gnorm"
	opentracing "github.com/opentracing/opentracing-go"
	"github.com/opentracing/opentracing-go/log"
	"github.com/pkg/errors"
)

// TableName is the primary table that this particular gnormed file deals with.
const TableName = "user"

// Row represents a row from 'user'.
type Row struct {
	UserID    int         // user_id (PK)
	Admin     bool        // admin
	CreatedAt time.Time   // created_at
	Password  gnorm.Bytea // password
	UpdatedAt time.Time   // updated_at
	Username  string      // username
}

// Field values for every column in User.
var (
	AdminCol     = "admin"
	CreatedAtCol = "created_at"
	PasswordCol  = "password"
	UpdatedAtCol = "updated_at"
	UserIDCol    = "user_id"
	UsernameCol  = "username"
)

// All retrieves all rows from 'user' as a slice of Row.
func All(ctx context.Context, db gnorm.DB) ([]Row, error) {
	qry := gnorm.Qry().Select(`admin, created_at, password, updated_at, user_id, username`)
	qry.From(`public.user`)
	sqlstr, _, err := qry.ToSql()
	if err != nil {
		return nil, err
	}

	var vals []Row
	q, err := db.Query(sqlstr)
	if err != nil {
		return nil, errors.Wrap(err, "query User")
	}
	for q.Next() {
		r := Row{}
		err := q.Scan(
			&r.Admin,
			&r.CreatedAt,
			&r.Password,
			&r.UpdatedAt,
			&r.UserID,
			&r.Username,
		)
		if err != nil {
			return nil, errors.Wrap(err, "all User")
		}
		vals = append(vals, r)
	}
	return vals, nil
}

// CountQuery retrieve one row from 'user'.
func CountQuery(ctx context.Context, db gnorm.DB, where []sq.Sqlizer) (int, error) {
	qry := gnorm.Qry().Select(`count(*) as count`)
	qry = qry.From("public.user")
	for _, w := range where {
		qry = qry.Where(w)
	}

	sqlstr, args, err := qry.ToSql()
	if err != nil {
		return 0, err
	}

	count := 0
	err = db.QueryRow(sqlstr, args...).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "count User")
	}
	return count, nil
}

// Query retrieves rows from 'user' as a slice of Row.
func Query(ctx context.Context, db gnorm.DB, where []sq.Sqlizer) ([]Row, error) {
	qry := gnorm.Qry().Select(`user_id, username, password, admin, created_at, updated_at`)
	qry = qry.From("public.user")
	for _, w := range where {
		qry = qry.Where(w)
	}

	sqlstr, args, err := qry.ToSql()
	if err != nil {
		return nil, err
	}

	var vals []Row
	q, err := db.Query(sqlstr, args...)
	if err != nil {
		return nil, errors.Wrap(err, "query User")
	}
	for q.Next() {
		r := Row{}
		err := q.Scan(
			&r.UserID,
			&r.Username,
			&r.Password,
			&r.Admin,
			&r.CreatedAt,
			&r.UpdatedAt,
		)
		if err != nil {
			return nil, errors.Wrap(err, "query User")
		}
		vals = append(vals, r)
	}
	return vals, nil
}

// PaginatedQuery Query used to get paginated results.  Can be replaced with
// a custom query of your own choosing that will allow you to sort or filter
// based on related fields as well
var PaginatedQuery = gnorm.
	Qry().
	Select("p.admin, p.created_at, p.password, p.updated_at, p.user_id, p.username").
	From("public.user as p")

// QueryPaginated retrieves rows from 'User' as a slice of Row.  If count == 0, then returns all results.  Returns true if there are more results to be had than those listed
// It will first grab a list of the relevant ID's, then fetch the full objects separately.  Done this way so that we can use custom queries that join more rows for use in sorting and filtering.
func QueryPaginated(ctx context.Context, db gnorm.DB, cursor *string, where []sq.Sqlizer, order gnorm.Order, count int64) (vals []Row, hasMore bool, total int, err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "QueryPaginated User")
	defer span.Finish()

	qry := PaginatedQuery

	for _, w := range where {
		qry = qry.Where(w)
	}

	sqlstr, args, err := qry.ToSql()
	if err != nil {
		return
	}

	// Get the total number of rows possible with our existing query, before we add the cursor related conditional
	countSQL := fmt.Sprintf("SELECT count(*) FROM (%s) AS xyz", sqlstr)
	span.LogFields(
		log.String("countQuery", countSQL),
	)
	err = db.QueryRow(countSQL, args...).Scan(&total)

	if err != nil {
		return
	}

	if cursor != nil {
		w, args := gnorm.PaginateCursorWhere(*cursor, order, sqlstr, "user_id")
		qry = qry.Where(w, args...)
	}

	err = order.AddField("user_id")
	if err != nil {
		return
	}

	// Order of results:
	qry = qry.OrderBy(order.String())

	if count > 0 {
		qry = qry.Limit(uint64(count) + 1)
	}

	sqlstr, args, err = qry.ToSql()
	if err != nil {
		return
	}

	pageQuery := fmt.Sprintf("SELECT user_id FROM (%s) AS xyz", sqlstr)
	span.LogFields(
		log.String("query", pageQuery),
	)
	q, err := db.Query(pageQuery, args...)
	if err != nil {
		return
	}

	// Collect the ID's together, and use them to fetch the full objects.  We do this in two stages because sometimes we will explicitly replace the auto-generated query used for this function, fullUserIDPaginatedQuery.  This allows us to use custom queries that are tailored to allow sorting and filtering by fields that may not be available in just the parent and child (version) tables alone.
	var fetchIDs []int
	for q.Next() {
		var r int

		err = q.Scan(&r)
		if err != nil {
			return
		}

		fetchIDs = append(fetchIDs, r)
	}

	if len(fetchIDs) == 0 {
		return
	}

	fetched, err := Query(ctx, db, []sq.Sqlizer{gnorm.InInt(UserIDCol, fetchIDs)})

	// Now create vals:
	vals = make([]Row, len(fetchIDs))

	found := 0
	for i, id := range fetchIDs {
		for _, v := range fetched {
			if id == v.UserID {
				vals[i] = v
				found++
				continue
			}
		}
	}

	if found != len(fetchIDs) {
		err = fmt.Errorf("Could not find all required records")
	}

	// If count was more than 0 and we received more results than count, there are more rows to fetch
	if count > 0 && int64(len(fetchIDs)) > count {
		hasMore = true
		vals = vals[:len(vals)-1]
	}

	return
}

// Find retrieves a row from 'user' by its primary key(s).
func Find(ctx context.Context, db gnorm.DB,
	userID int,
) (Row, error) {
	const sqlstr = `SELECT
		admin, created_at, password, updated_at, user_id, username
	FROM public.user WHERE ( user_id = $1 )`

	r := Row{}
	err := db.QueryRow(sqlstr,
		userID,
	).Scan(&r.Admin,
		&r.CreatedAt,
		&r.Password,
		&r.UpdatedAt,
		&r.UserID,
		&r.Username,
	)
	if err != nil {
		return Row{}, errors.Wrap(err, "find User")
	}
	return r, nil
}

// One retrieve one row from 'user'.
func One(ctx context.Context, db gnorm.DB, where []sq.Sqlizer, order *gnorm.Order) (Row, error) {
	qry := gnorm.Qry().Select(`user_id, username, password, admin, created_at, updated_at`)
	qry = qry.From("public.user")

	for _, w := range where {
		qry = qry.Where(w)
	}

	if order != nil {
		qry = qry.OrderBy(order.String())
	}

	qry = qry.Limit(1)

	sqlstr, args, err := qry.ToSql()
	if err != nil {
		return Row{}, err
	}

	r := Row{}
	err = db.QueryRow(sqlstr, args...).Scan(&r.UserID,
		&r.Username,
		&r.Password,
		&r.Admin,
		&r.CreatedAt,
		&r.UpdatedAt,
	)
	if err != nil {
		return Row{}, errors.Wrap(err, "queryOne User")
	}
	return r, nil
}

// Upsert Creates or updates record based on input
func Upsert(ctx context.Context, db gnorm.DB, o Row) (Row, error) {
	span, _ := opentracing.StartSpanFromContext(ctx, "UpsertUser")
	defer span.Finish()

	var err error
	if err = prepareCreate(ctx, &o); err != nil {
		return o, err
	}

	// sql query
	const sqlstr = `INSERT INTO public.user (` +
		`admin, created_at, password, updated_at, user_id, username` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6` +
		`) ON CONFLICT (user_id) DO UPDATE SET (` +
		`admin, created_at, password, updated_at, user_id, username` +
		`) = (` +
		`EXCLUDED.admin, EXCLUDED.created_at, EXCLUDED.password, EXCLUDED.updated_at, EXCLUDED.user_id, EXCLUDED.username` +
		`)`

	// run query
	_, err = db.Exec(sqlstr, o.Admin, o.CreatedAt, o.Password, o.UpdatedAt, o.UserID, o.Username)
	if err != nil {
		return o, err
	}

	return o, nil
}

// Delete deletes the Row from the database. Returns the number of items deleted.
func Delete(ctx context.Context,
	db gnorm.DB,
	userID int,
) (int64, error) {
	const sqlstr = `DELETE FROM public.user 
	WHERE
	  user_id = $1
	`

	res, err := db.Exec(sqlstr, userID)
	if err != nil {
		return 0, errors.Wrap(err, "delete User")
	}
	rows := res.RowsAffected()
	return rows, nil
}

// DeleteWhere deletes Rows from the database and returns the number of rows deleted.
func DeleteWhere(ctx context.Context, db gnorm.DB, where []sq.Sqlizer) (int64, error) {
	qry := gnorm.Qry().Delete("")
	qry = qry.From("public.user")
	for _, w := range where {
		qry = qry.Where(w)
	}

	sqlstr, args, err := qry.ToSql()
	if err != nil {
		return 0, err
	}

	res, err := db.Exec(sqlstr, args...)
	if err != nil {
		return 0, errors.Wrap(err, "delete User")
	}
	return res.RowsAffected(), nil
}

// DeleteAll deletes all Rows from the database and returns the number of rows deleted.
func DeleteAll(ctx context.Context, db gnorm.DB) (int64, error) {
	const sqlstr = `DELETE FROM public.user`

	res, err := db.Exec(sqlstr)
	if err != nil {
		return 0, errors.Wrap(err, "deleteall User")
	}
	return res.RowsAffected(), nil
}

// Update Updates with the provided records and condition
func Update(ctx context.Context, db gnorm.DB, updates map[string]interface{}, where []sq.Sqlizer) (int64, error) {
	qry := gnorm.Qry().Update("").Table("public.user")

	if _, ok := updates["updated_at"]; !ok {
		updates["updated_at"] = time.Now()
	}

	qry = qry.SetMap(updates)
	for _, w := range where {
		qry = qry.Where(w)
	}

	sqlstr, args, err := qry.ToSql()
	if err != nil {
		return 0, err
	}

	res, err := db.Exec(sqlstr, args...)
	if err != nil {
		return 0, errors.Wrap(err, "update User")
	}
	return res.RowsAffected(), nil
}

// prepareCreate Prepares some fields for a new row if they haven't been provided already.  For example, primary key UUID values, created, etc
func prepareCreate(ctx context.Context, o *Row) error {
	span, ctx := opentracing.StartSpanFromContext(ctx, "prepareCreate User")
	defer span.Finish()

	if o == nil {
		return nil
	}

	// Set created time if not set
	if o.CreatedAt.IsZero() {
		o.CreatedAt = time.Now()
	}

	// Set updated to now
	o.UpdatedAt = time.Now()

	return nil
}
