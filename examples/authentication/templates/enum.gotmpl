// Code generated by gnorm, DO NOT EDIT!

package enum

import (
	"{{.Params.RootImport}}"
	"github.com/pkg/errors"
)

{{$rootPkg := .Params.RootPkg}}

{{- $type := .Enum.Name -}}

// {{ $type }} is the '{{ .Enum.DBName }}' enum type from schema '{{ .Enum.Schema.Name  }}'.
type {{ $type }} uint16

const (
    // Unknown{{$type}} defines an invalid {{$type}}.
    Unknown{{$type}} {{$type}} = 0
{{- range .Enum.Values }}
	{{ .Name }}{{ $type }} {{$type}} = {{ .Value }}
{{ end -}}
)

// String returns the string value of the {{ $type }}.
func (e {{ $type }}) String() string {
	switch e {
{{- range .Enum.Values }}
	case {{ .Name }}{{ $type }}:
		return "{{ .DBName }}"
{{- end }}
	default:
    	return "Unknown{{$type}}"
    }
}

// MarshalText marshals {{ $type }} into text.
func (e {{ $type }}) MarshalText() ([]byte, error) {
	return []byte(e.String()), nil
}

// UnmarshalText unmarshals {{ $type }} from text.
func (e *{{ $type }}) UnmarshalText(text []byte) error {
    val, err := Parse{{$type}}(string(text))
    if err != nil {
        return err
    }
    *e = val
    return nil
}

// Parse{{$type}} converts s into a {{$type}} if it is a valid
// stringified value of {{$type}}.
func Parse{{$type}}(s string) ({{$type}}, error) {
	switch s {
{{- range .Enum.Values }}
	case "{{ .DBName }}":
		return {{ .Name }}{{ $type }}, nil
{{- end }}
	default:
		return Unknown{{$type}}, errors.New("invalid {{ $type }}")
	}
}

// Value satisfies the sql/driver.Valuer interface for {{ $type }}.
func (e {{ $type }}) Value() (driver.Value, error) {
	return e.String(), nil
}

// Scan satisfies the database/sql.Scanner interface for {{ $type }}.
func (e *{{ $type }}) Scan(src interface{}) error {
	buf, ok := src.([]byte)
	if !ok {
	   return errors.New("invalid {{ $type }}")
	}

	return e.UnmarshalText(buf)
}

// {{$type}}Field is a component that returns a {{$rootPkg}}.Where that contains a
// comparison based on its field and a strongly typed value.
type {{$type}}Field string

// Equals returns a {{$rootPkg}}.WhereClause for this field.
func (f {{$type}}Field) Equals(v {{$type}}) {{$rootPkg}}.Where {
	return {{$rootPkg}}.Where{
		Field: string(f),
		Comp:  {{$rootPkg}}.CompEqual,
		Value: v,
	}
}

// GreaterThan returns a {{$rootPkg}}.Where for this field.
func (f {{$type}}Field) GreaterThan(v {{$type}}) {{$rootPkg}}.Where {
	return {{$rootPkg}}.Where{
		Field: string(f),
		Comp:  {{$rootPkg}}.CompGreater,
		Value: v,
	}
}

// LessThan returns a {{$rootPkg}}.Where for this field.
func (f {{$type}}Field) LessThan(v {{$type}}) {{$rootPkg}}.Where {
	return {{$rootPkg}}.Where{
		Field: string(f),
		Comp:  {{$rootPkg}}.CompEqual,
		Value: v,
	}
}

// GreaterOrEqual returns a {{$rootPkg}}.Where for this field.
func (f {{$type}}Field) GreaterOrEqual(v {{$type}}) {{$rootPkg}}.Where {
	return {{$rootPkg}}.Where{
		Field: string(f),
		Comp:  {{$rootPkg}}.CompGTE,
		Value: v,
	}
}

// LessOrEqual returns a {{$rootPkg}}.Where for this field.
func (f {{$type}}Field) LessOrEqual(v {{$type}}) {{$rootPkg}}.Where {
	return {{$rootPkg}}.Where{
		Field: string(f),
		Comp:  {{$rootPkg}}.CompLTE,
		Value: v,
	}
}

// NotEqual returns a {{$rootPkg}}.Where for this field.
func (f {{$type}}Field) NotEqual(v {{$type}}) {{$rootPkg}}.Where {
	return {{$rootPkg}}.Where{
		Field: string(f),
		Comp:  {{$rootPkg}}.CompNE,
		Value: v,
	}
}


// In returns a {{$rootPkg}}.Where for this field.
func (f {{$type}}Field) In(vals []{{$type}}) {{$rootPkg}}.InClause {
	values := make([]interface{}, len(vals))
	for x := range vals {
		values[x] = vals[x]
	}
	return {{$rootPkg}}.InClause{
		Field: string(f),
		Vals: values,
	}
}
