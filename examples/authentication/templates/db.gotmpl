// Code generated by gnorm, DO NOT EDIT!

package {{.Params.RootPkg}}

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"strconv"
	"strings"

	"github.com/pkg/errors"
	"github.com/jackc/pgx"
	sq "github.com/Masterminds/squirrel"
)

var safeField = regexp.MustCompile(`^[a-zA-Z_0-9]+\z`)


// DB is the common interface for database operations.
// This should work with database/sql.DB and database/sql.Tx.
type DB interface {
	Exec(string, ...interface{}) (pgx.CommandTag, error)
	Query(string, ...interface{}) (*pgx.Rows, error)
	QueryRow(string, ...interface{}) *pgx.Row
}

// Order Specifies an order for field
type Order struct {
	Fields     []string
	Descending bool
}

// NewOrder Convenience function to return new order
func NewOrder(descending bool) Order {
	return Order{Descending: descending}
}

// AddField Add a field to sort by
func (o *Order) AddField(field string) error {
	// Extra layer to help prevent SQL injection attack
	if !safeField.MatchString(field) {
		return fmt.Errorf("Invalid field for sorting")
	}

	o.Fields = append(o.Fields, field)

	return nil
}

// Length Returns how many fields are being sorted by
func (o *Order) Length() int {
	return len(o.Fields)
}

// String Returns an order string
func (o *Order) String() string {
	ord := "ASC"

	if o.Descending {
		ord = "DESC"
	}

	str := strings.Join(o.Fields, fmt.Sprintf(" %s, ", ord))
	if len(o.Fields) == 0 {
		str = "true"
	}
	return str + " " + ord
}

// Bytea is a wrapper around byte arrays specifically for bytea column types in postgres.
type Bytea []byte

// Jsonb is a wrapper for map[string]interface{} for storing json into postgres
type Jsonb map[string]interface{}

// Value marshals the json into the database
func (j Jsonb) Value() (driver.Value, error) {
	return json.Marshal(j)
}

// Scan Unmarshalls the bytes[] back into a Jsonb object
func (j *Jsonb) Scan(src interface{}) error {
	source, ok := src.([]byte)
	if !ok {
		return errors.New("Type assertion .([]byte) failed")
	}

	var i interface{}
	err := json.Unmarshal(source, &i)
	if err != nil {
		return err
	}

	if i == nil {
		return nil
	}

	*j, ok = i.(map[string]interface{})
	if !ok {
		return errors.New("reading from DB into Jsonb, failed to convert to map[string]interface{}")
	}

	return nil
}

func PaginateCompare(fields []string, parentKey string, query string) (string, string) {
	//FIX TO NOT INCLUDE CLIENT AN EXTRA TIME
	var compLeft []string
	var compRight []string

	for _, f := range fields {
		compLeft = append(compLeft, f)
		compRight = append(compRight, fmt.Sprintf("(SELECT %s FROM (%s) AS sd WHERE sd.%s = ?)", f, query, parentKey))
	}

	return strings.Join(compLeft, ", "), strings.Join(compRight, ", ")
}

func PaginateCursorWhere(cursor string, order Order, sqlstr string, field string) (string, []interface{}) {
	var args []interface{}
	var sql string
	lgt := ">"
	if order.Descending {
		lgt = "<"
	}

	// Create the key function that allows us to limit ourselves to only results following the cursor.  We always sort by the primary key at the end to ensure a deterministic ordering of results.  No result left behind.
	compLeft, compRight := PaginateCompare(order.Fields, field, sqlstr)

	if len(compLeft) > 0 {
		sql = fmt.Sprintf(" (%s, todo_id) %s (%s, ?)", compLeft, lgt, compRight)
	} else {
		sql = fmt.Sprintf(" (todo_id) %s (?)", lgt)
	}
	for range order.Fields {
		args = append(args, cursor)
	}
	args = append(args, cursor)

	return sql, args
}

// Qry Returns a new squirrel query builder.  Will one day check database
// type and return appropriate type
func Qry() sq.StatementBuilderType {
	return sq.StatementBuilder.PlaceholderFormat(sq.Dollar)
}

func RollbackErr(err error, tx *pgx.Tx) error {
	if err != nil {
		tx.Rollback()
		return err
	}
	return nil
}
